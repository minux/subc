

	PORTING SUBC TO DIFFERENT PLATFORMS


	(1)  Create a new target description file

	Copy one of the existing cg*.c files in the src/targets
	directory to create a new target description. The target
	description will contain the instructions that will be
	emitted by the code generator. Also copy the corresponding
	cg*.h file. For example, to create an FOO back-end:

		cp src/targets/cg386-stk.c src/targets/cgxFOO.c
		cp src/targets/cg386.h src/targets/cgxFOO.h

	For some targets, there may be two different descriptions,
	one ending in '-stk.c' and one ending in '-syn.c'. They
	contain the 'stack-based' and 'synthesizing' back-end,
	respectively. When in doubt, use the stack-based one. While
	it generates larger and slower code than the synthesizing
	back-end, it is easier to understand and covered in greater
	detail by the book.

	Make sure to use the proper generator with your new target
	description. Use targets/stkgen.c for stack-based back-ends
	and targets/syngen.c for synthesizing ones.


	(2) Select the proper machine word size

	Edit the newly created header file (e.g.: cgFOO.h) and
	change its BPW constant to the *natural* machine word size
	on the new target. This would be 32 bits for a 32-bit
	processor, 64 bits for a 64-bit processor, etc. Note that
	the word size selected here must be large enough to hold
	an arbitrary address (a pointer) on the target. Incidentally,
	the selected size will be sizeof(int) in the new back-end.


	(3) Create en environment desscription for your OS

	The SubC compiler uses some external resources that are part
	of your operating system, like the assembler, linker, and
	maybe the system's C library. The environment file should be
	named after the OS (e.g.: linux.h) and contain the full paths
	or templates for accessing any external resources. Best use
	one of the existing files for a template.


	(4) Create a target description

	This is one of the hard parts. You will have to replace the
	code emitted by each function in the new target description
	file to generate code for your new platform. If you are an
	experienced compiler writer and you are familiar with one of
	the existing targets, you may be able to guess the proper
	sequences. Otherwise, you probably need a copy of the book
	"Practical Compiler Construction"[1] now, which explains the
	target description format in detail.

	[1] See the README file.

	For instance, to adapt the 386 target to the x86-64 processor,
	this step basically involves (a) replacing register names (%eax
	to %rax, etc), (b) replacing instruction suffixes (movl->movq,
	etc), (c) replacing ".long" by ".quad", and (d) adjusting all
	values that deal with word size, i.e. adding multiples of 8
	instead of 4 to registers in pointer arithmetics, etc.

	Of course, other processors will differ from the 386 by a far
	greater margin, so this step will be quite a piece of work.
	The conclusion part of the book contains some practical tips
	for approaching this task.


	(5) Create an OS-specific C startup file

	Copy one of the existing crt0-*.s files in the src/targets
	directory to create a new startup file. For example, to create
	a NetBSD/FOO startup file:

		cp src/targets/crt0-freebsd-386.s \
		   src/targets/crt0-netbsd-foo.s


	(6) Create the OS interface

	This step is a mess and requires some decent in-depth knowledge
	of the target platform, i.e. its internal command line argument
	format, environment location, its calling conventions, etc.

	Again, if you are really familiar with one of the supported
	platforms, you may be able to rewrite the individual functions.
	Otherwise, this is a good time to pick up a copy of "Practical
	Compiler Construction", which also explains this part in depth.

	You may run into a lot of trouble at this point. Be patient,
	this is to be expected.


	(7) Compile, test, repeat

	A lot of things *will* go wrong. Do not get discouraged! This
	is normal. First make the compiler emit syntactically correct
	assembler code. Then make it compile the library. Then test
	some small programs. Then compile the compiler with itself.
	Once it passes the triple test (make test), the compiler can
	be considered stable.

	Pointer arithmetics can be particularly nasty, so there is an
	ad-hoc pointer arithmetics test suite included in the SubC
	archive. Just run 'make ptest' in src/. When it does not print
	anything, fine!


	(8) Add your back-end to the configure script

	Have a look at the configure script in the root of the SubC
	source tree and add your configuration. It is just a simple,
	human readable script containing no magic whatsoever, so this
	should be a piece of cake.


	(9) Optionally: send your patches to the author

	Thank you!

