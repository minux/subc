

	THE SUBC BACK-END

	As of version 2013-02-19, the SubC compiler uses an improved
	back-end, which creates (synthesizes) machine instructions
	instead of using pre-existing static templates. The technique
	is described in Practical Compiler Construction, but only at
	a rather abstract level. The current version of SubC contains
	an implementation of this approach.

	Here is a comparison between the original compiler (the book
	version) and the current version (2014-03-06):

				 Book	Current	Difference
		bootstrap	 1.05s	 0.82s	0.23s (22%)
		text size	79,488	71,658	
		data size	10,272	 8,756
		adj. text size	79,488	70,142	 9346 (12%)

	Run times were obtained by bootstrapping the current version
	on a 386-class machine. See the last section of this file for
	details.

	The adjusted difference in text size is obtained by subtracting
	the data size difference from the text size generated by the new
	back end. This is done, because the book back end kept switch
	tables in the data segment, while the new one keeps them in the
	text segment.

	So the code generated by the current version is about 22%
	faster and 12% smaller than the code emitted by the book
	version.


	CODE SAMPLES

	The following code would be emitted for the fragment

		a+b-c

	on 386-based machines:		on arm-based machines:
        movl    20(%ebp),%eax		add     r0,r11,#20
        movl    16(%ebp),%ecx		ldr     r0,[r0]   
        addl    %ecx,%eax		add     r1,r11,#16
        movl    12(%ebp),%ecx		ldr     r1,[r1]   
        subl    %ecx,%eax		add     r0,r0,r1  
					add     r1,r11,#12
					ldr     r1,[r1]   
					sub     r0,r0,r1  

	The compiler does not perform register allocation. Intermediate
	results are kept on the stack, so

		a+b*c

	would result in the following fragments:

	# 386				# arm
	movl    20(%ebp),%eax		add     r0,r11,#20
	pushl   %eax			ldr     r0,[r0]   
	movl    16(%ebp),%eax		push    {r0}      
	movl    12(%ebp),%ecx		add     r0,r11,#16
	imull   %ecx,%eax		ldr     r0,[r0]   
	popl    %ecx			add     r1,r11,#12
	addl    %ecx,%eax		ldr     r1,[r1]   
					mul     r0,r0,r1  
					pop     {r1}      
					add     r0,r0,r1  

	Furthermore, the emitted code uses traditional Unix calling
	conventions, so all function arguments are passed on the stack.

	On the armv6, a separate indirect address is currently being
	generated for each *access* to a global or static variable,
	so the expression

		a+a

	would compile to:

		ldr     r0,L2
		b       L3
	L2:     .long   Ca
	L3:     ldr     r0,[r0]
		ldr     r1,L4
		b       L5
	L4:     .long   Ca
	L5:     ldr     r1,[r1]
		add     r0,r0,r1


	SO, HOW BAD IS THE CODE, REALLY?

	Its turns out that the code generated by the SubC compiler is
	not *that* bad at all. On 32-bit platforms it generates pretty
	compact code, and on 64-bit platforms its code only appears
	so large, because it uses 64-bit ints. (This means that, for
	example, 123 is represented by 0x000000000000007f, which tends
	to expand the code a bit).

	On 32-bit machines, the self-compiled SubC binary is about
	1/3 the size of the corresponding files generated by GCC
	and Clang. Of course, this is also due to the simple LIBC
	implementation used by SubC.

	On the other hand, the generated code runs about twice as
	long as the code generated by Clang or GCC, even at optimization
	level 0.

	See the below tables for some sample results.
	
	Run times were obtained by running

		time cc -S *.c
		time scc -S *.c

	in the src/ directory multiple times and taking the best results.
	All sizes refer to statically linked executables.

	The SCC0 bootstrap time is the time taken by the GCC-compiled
	or Clang-compiled SubC compilers, while the primary bootstrap
	time is the time taken by a self-compiled SubC compiler.

	FreeBSD 8.2-RELEASE, 686 CPU @ 600 MHz
				GCC 4.2.1	SUBC 2014-03-06
		bootstrap	  1.73s		  0.82s (SCC0: 0.38)
		sizeof(int)	      4		      4
		text size	223,485		 71,658
		data size	  8,112		  8,756
		bss size	 77,768		 41,112
		file size	252,548		 80,860

	FreeBSD 10.0-RC5, armv6 CPU @ 700 MHz
				Clang 3.3	SUBC 2014-03-06
		bootstrap	 10.19s		  3.05s (SCC0: 1.95)
		sizeof(int)	      4		      4
		text size	442,603		151,864
		data size	  9,064		  8,712
		bss size	121,168		 41,112
		file size	464,808		161,092

	NetBSD 6.1-STABLE, x86-64 CPU @ 2400 MHz
				GCC 4.5.3	SUBC 2014-03-06
		bootstrap	  0.87s		  0.36s	(SCC0: 0.22)
		sizeof(int)	      4		      8 (!)
		text size	242,108		255,108
		data size	  4,768		 14,496
		bss size	 67,176		 79,792
		file size	256,992		277,480

